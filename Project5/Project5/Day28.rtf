{\rtf1\ansi\ansicpg1251\cocoartf2578
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Bold;
\f3\fnil\fcharset0 HelveticaNeue-Italic;\f4\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red235\green0\blue121;\red24\green24\blue28;
\red246\green246\blue239;\red157\green101\blue255;\red72\green212\blue251;\red212\green212\blue212;\red215\green165\blue255;
\red222\green43\blue91;\red248\green60\blue79;\red74\green200\blue164;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c94902\c14118\c54902;\cssrgb\c12549\c12549\c14510;
\cssrgb\c97255\c97255\c94902;\cssrgb\c68235\c50588\c100000;\cssrgb\c32941\c86275\c98824;\cssrgb\c86275\c86275\c86275;\cssrgb\c87843\c72157\c100000;
\cssrgb\c90588\c27059\c43137;\cssrgb\c98824\c33725\c38039;\cssrgb\c33725\c81569\c70196;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\b\fs70 \cf2 \expnd0\expndtw0\kerning0
Project 5, part two\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs28 \cf2 \
\pard\pardeftab720\partightenfactor0

\fs35\fsmilli17600 \cf2 Language is complicated.\
\
We can see further evidence of how complicated language is by looking at the way Swift handles strings. Have you ever wondered why you can\'92t read individual letters from strings using integer positions? In code, this kind of thing isn\'92t built into Swift: 
\f2\b let letter = someString[5]
\f1\b0 \
The reason for this is that Swift uses a rather complicated \'96 but extremely important! \'96 system of storing its characters, known as 
\f3\i extended grapheme clusters
\f1\i0 . This means for Swift to read character 8 of a string it needs to start at 0 and count through individual letters until it reaches the 8th one; it can\'92t jump straight there.\
As a result, Swift doesn\'92t let us use 
\f2\b str[7]
\f1\b0  to read the 8th character \'96\'a0even though they could enable such behavior trivially, it could easily result in folks using integer subscripting inside a loop, which would have 
\f3\i terrible
\f1\i0  performance.\
All this matters because today you\'92re going to be using 
\f2\b UITextChecker
\f1\b0  to check whether a string is spelled correctly. This comes from UIKit, which was written in Objective-C, so we need to be very careful how we give it Swift strings to use.\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 Today you have three topics to work through, and you\'92ll learn about using 
\f2 UITextChecker
\f0  to find invalid words, inserting table view rows with animation, and more.
\f1\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/5/4/prepare-for-submission-lowercased-and-indexpath"}}{\fldrslt \expnd0\expndtw0\kerning0
Prepare for submission: lowercased() and IndexPath}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/5/5/checking-for-valid-answers"}}{\fldrslt \expnd0\expndtw0\kerning0
Checking for valid answers}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/5/6/or-else-what"}}{\fldrslt \expnd0\expndtw0\kerning0
Or else what?}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
\
\pard\tx560\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Prepare for submission: lowercased() and IndexPath
\f1\b0\fs35\fsmilli17600 \
You can breathe again: we're done with closures for now. I know that wasn't easy, but once you understand basic closures you really have come a long way in your Swift adventure.\
We're going to do some much easier coding now, because believe it or not we're not that far from making this game actually work!\
We have now gone over the structure of a closure: trailing closure syntax, unowned self, a parameter being passed in, then the need for 
\f2\b self.
\f1\b0  to make capturing clear. We haven't really talked about the actual content of our closure, because there isn't a lot to it. As a reminder, here's how it looks:\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 guard
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  answer = ac?.textFields?[\cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ].text 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{ 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \}\

\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ?.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 submit\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (answer)\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 The first line safely unwraps the array of text fields \'96 it's optional because there might not be any. The second line pulls out the text from the text field and passes it to our (all-new-albeit-empty) 
\f2\b submit()
\f1\b0  method.\
This method needs to check whether the player's word can be made from the given letters. It needs to check whether the word has been used already, because obviously we don't want duplicate words. It also needs to check whether the word is actually a valid English word, because otherwise the user can just type in nonsense.\
\
This method needs to check whether the player's word can be made from the given letters. It needs to check whether the word has been used already, because obviously we don't want duplicate words. It also needs to check whether the word is actually a valid English word, because otherwise the user can just type in nonsense.\
If all three of those checks pass, 
\f2\b submit()
\f1\b0  needs to add the word to the 
\f2\b usedWords
\f1\b0  array, then insert a new row in the table view. We could just use the table view's 
\f2\b reloadData()
\f1\b0  method to force a full reload, but that's not very efficient when we're changing just one row.\
First, let\'92s create dummy methods for the three checks we\'92re going to do: is the word possible, is it original, and is it real? Each of these will accept a word string and return true or false, but for now we\'92ll just always return true \'96 we\'92ll come back to these soon. Add these methods now:\cf8 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isPossible\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) -> \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Bool\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\

\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isOriginal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) -> \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Bool\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\

\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isReal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) -> \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Bool\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}
\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 \
\
\pard\pardeftab720\partightenfactor0
\cf8 With those three methods in place, we can write our first pass at the 
\f2\b \cf10 submit()
\f1\b0 \cf8  method:\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 submit\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 _\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  answer: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  lowerAnswer = answer.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 lowercased\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isPossible\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
        
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isOriginal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
            
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isReal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
                usedWords.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 insert\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (answer, at: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
\
                
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  indexPath = \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 IndexPath\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (row: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , section: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
                tableView.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 insertRows\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (at: [indexPath], with: .automatic)\
            \}\
        \}\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 If a user types "cease" as a word that can be made out of our started word "agencies", it's clear that is correct because there is one "c", two "e"s, one "a" and one "s". But what if they type "Cease"? Now it has a capital C, and "agencies" doesn't have a capital C. Yes, that's right: strings are case-sensitive, which means Cease is not cease is not CeasE is not CeAsE.\
The solution to this is quite simple: all the starter words are lowercase, so when we check the player's answer we immediately lowercase it using its 
\f2\b lowercased()
\f1\b0  method. This is stored in the 
\f2\b lowerAnswer
\f1\b0  constant because we want to use it several times.\cf8 \
\cf2 \
The solution to this is quite simple: all the starter words are lowercase, so when we check the player's answer we immediately lowercase it using its 
\f2\b lowercased()
\f1\b0  method. This is stored in the 
\f2\b lowerAnswer
\f1\b0  constant because we want to use it several times.\
We then have three 
\f2\b if
\f1\b0  statements, one inside another. These are called nested statements, because you nest one inside the other. Only if all three statements are true (the word is possible, the word hasn't been used yet, and the word is a real word), does the main block of code execute.\
Once we know the word is good, we do three things: insert the new word into our 
\f2\b usedWords
\f1\b0  array at index 0. This means "add it to the start of the array," and means that the newest words will appear at the top of the table view.\
The next two things are related: we insert a new row into the table view. Given that the table view gets all its data from the used words array, this might seem strange. After all, we just inserted the word into the 
\f2\b usedWords
\f1\b0  array, so why do we need to insert anything into the table view?\
The answer is animation. Like I said, we could just call the 
\f2\b reloadData()
\f1\b0  method and have the table do a full reload of all rows, but it means a lot of extra work for one small change, and also causes a jump \'96 the word wasn't there, and now it is.\
This can be hard for users to track visually, so using 
\f2\b insertRows()
\f1\b0  lets us tell the table view that a new row has been placed at a specific place in the array so that it can animate the new cell appearing. Adding one cell is also significantly easier than having to reload everything, as you might imagine!\
\
There are two quirks here that require a little more detail. First, 
\f2\b IndexPath
\f1\b0  is something we looked at briefly in project 1, as it contains a section and a row for every item in your table. As with project 1 we aren't using sections here, but the row number should equal the position we added the item in the array \'96 position 0, in this case.\
Second, the 
\f2\b with
\f1\b0  parameter lets you specify how the row should be animated in. Whenever you're adding and removing things from a table, the 
\f2\b .automatic
\f1\b0  value means "do whatever is the standard system animation for this change." In this case, it means "slide the new row in from the top."\
Our three checking methods always return true regardless of what word is entered, but apart from that the game is starting to come together. Press Cmd+R to play back what you have: you should be able to tap the + button and enter words into the alert.\
\
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Checking for valid answers
\f1\b0\fs35\fsmilli17600 \
As you\'92ve seen, the 
\f2\b return
\f1\b0  keyword exits a method at any time it's used. If you use 
\f2\b return
\f1\b0  by itself, it exits the method and does nothing else. But if you use 
\f2\b return
\f1\b0  with a value, it sends that value back to whatever called the method. We\'92ve used it previously to send back the number of rows in a table, for example.\
Before you can send a value back, you need to tell Swift that you expect to return a value. Swift will automatically check that a value is returned and it's of the right data type, so this is important. We just put in stubs (empty methods that do nothing) for three new methods, each of which returns a value. Let's take a look at one in more detail:\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf2 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  isOriginal(word: String) -> Bool \{\
    
\f2\b \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  true\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 The method is called 
\f2\b isOriginal()
\f1\b0 , and it takes one parameter that's a string. But before the opening brace there's something important: 
\f2\b -> Bool
\f1\b0 . This tells Swift that the method will return a boolean value, which is the name for a value that can be either true or false.\
The body of the method has just one line of code: 
\f2\b return true
\f1\b0 . This is how the 
\f2\b return
\f1\b0  statement is used to send a value back to its caller: we're returning true from this method, so the caller can use this method inside an 
\f2\b if
\f1\b0  statement to check for true or false.\
This method can have as much code as it needs in order to evaluate fully whether the word has been used or not, including calling any other methods it needs. We're going to change it so that it calls another method, which will check whether our 
\f2\b usedWords
\f1\b0  array already contains the word that was provided. Replace its current 
\f2\b return true
\f1\b0  code with this:\cf8 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  !usedWords.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 contains\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word)\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 There are two new things here. First, 
\f2\b contains()
\f1\b0  is a method that checks whether the array it\'92s called on (
\f2\b usedWords
\f1\b0 ) contains the value specified in parameter 2 (
\f2\b word
\f1\b0 ). If it does contain the value, 
\f2\b contains()
\f1\b0  returns true; if not, it returns false. Second, the 
\f2\b !
\f1\b0  symbol. You've seen this before as the way to force unwrap optional variables, but here it's something different: it means 
\f3\i not
\f1\i0 .\
The difference is small but important: when used before a variable or constant, 
\f2\b !
\f1\b0  means "not" or "opposite". So if 
\f2\b contains()
\f1\b0  returns true, 
\f2\b !
\f1\b0  flips it around to make it false, and vice versa. When used after a variable or constant, 
\f2\b !
\f1\b0  means "force unwrap this optional variable."\
This is used because our method is called 
\f2\b isOriginal()
\f1\b0 , and should return true if the word has never been used before. If we had used 
\f2\b return usedWords.contains(word)
\f1\b0 , then it would do the opposite: it would return true if the word had been used and false otherwise. So, by using 
\f2\b !
\f1\b0  we're flipping it around so that the method returns true if the word is new.\
\
That's one method down. Next is the 
\f2\b isPossible()
\f1\b0 , which also takes a string as its only parameter and returns a 
\f2\b Bool
\f1\b0  \'96 true or false. This one is more complicated, but I've tried to make the algorithm as simple as possible.\
How can we be sure that "cease" can be made from "agencies", using each letter only once? The solution I've adopted is to loop through every letter in the player's answer, seeing whether it exists in the eight-letter start word we are playing with. If it does exist, we remove the letter from the start word, then continue the loop. So, if we try to use a letter twice, it will exist the first time, but then get removed so it doesn't exist the next time, and the check will fail.\
In project 4 we used the 
\f2\b contains()
\f1\b0  method to see if one string exists inside another. Here we need something more precise: if it exists, 
\f3\i where
\f1\i0 ? That extra information allows us to remove the character from our word so that it won\'92t be used twice. Swift has a separate method for this called 
\f2\b firstIndex(of:)
\f1\b0 , which will return the first position of the substring if it exists or nil otherwise.\
To put that into practice, here\'92s the 
\f2\b isPossible()
\f1\b0  method:\cf8 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isPossible\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) -> \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Bool\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 guard
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 var
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  tempWord = title?.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 lowercased\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 () 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{ 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 false\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \}\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 for
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  letter 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 in
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  word \{\
        
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  position = tempWord.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 firstIndex\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (of: letter) \{\
            tempWord.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 remove\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (at: position)\
        \} 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
            
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 false\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \}\
    \}\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 If the letter was found in the string, we use 
\f2\b remove(at:)
\f1\b0  to remove the used letter from the 
\f2\b tempWord
\f1\b0  variable. This is why we need the 
\f2\b tempWord
\f1\b0  variable at all: because we'll be removing letters from it so we can check again the next time the loop goes around.\
The method ends with 
\f2\b return true
\f1\b0 , because this line is reached only if every letter in the user's word was found in the start word no more than once. If any letter isn't found, or is used more than possible, one of the 
\f2\b return false
\f1\b0  lines would have been hit, so by this point we're sure the word is good.\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 Important:
\f1\b0  we have told Swift that we are returning a boolean value from this method, and it will check every possible outcome of the code to make sure a boolean value is returned no matter what.\
\
\pard\pardeftab720\partightenfactor0
\cf2 Time for the final method. Replace the current 
\f2\b isReal()
\f1\b0  method with this:\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isReal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) -> \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Bool\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  checker = \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 UITextChecker\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  range = \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 NSRange\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (location: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , length: word.utf16.\cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 count\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  misspelledRange = checker.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 rangeOfMisspelledWord\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 in
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 : word, range: range, startingAt: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , wrap: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 false\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , language: \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "en"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  misspelledRange.location == \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 NSNotFound\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 There's a new class here, called 
\f2\b UITextChecker
\f1\b0 . This is an iOS class that is designed to spot spelling errors, which makes it perfect for knowing if a given word is real or not. We're creating a new instance of the class and putting it into the 
\f2\b checker
\f1\b0  constant for later.\
There's a new type here too, called 
\f2\b NSRange
\f1\b0 . This is used to store a string range, which is a value that holds a start position and a length. We want to examine the whole string, so we use 0 for the start position and the string's length for the length.\
Next, we call the 
\f2\b rangeOfMisspelledWord(in:)
\f1\b0  method of our 
\f2\b UITextChecker
\f1\b0  instance. This wants five parameters, but we only care about the first two and the last one: the first parameter is our string, 
\f2\b word
\f1\b0 , the second is our range to scan (the whole string), and the last is the language we should be checking with, where 
\f2\b en
\f1\b0  selects English.\
Parameters three and four aren't useful here, but for the sake of completeness: parameter three selects a point in the range where the text checker should start scanning, and parameter four lets us set whether the 
\f2\b UITextChecker
\f1\b0  should start at the beginning of the range if no misspelled words were found starting from parameter three. Neat, but not helpful here.\
Calling 
\f2\b rangeOfMisspelledWord(in:)
\f1\b0  returns another 
\f2\b NSRange
\f1\b0  structure, which tells us where the misspelling was found. But what we care about was whether any misspelling was found, and if nothing was found our 
\f2\b NSRange
\f1\b0  will have the special location 
\f2\b NSNotFound
\f1\b0 . Usually 
\f2\b location
\f1\b0  would tell you where the misspelling started, but 
\f2\b NSNotFound
\f1\b0  is telling us the word is spelled correctly \'96 i.e., it's a valid word.\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 Note:
\f1\b0  In case you were curious, 
\f2\b NSRange
\f1\b0  pre-dates Swift, and therefore doesn\'92t have access to optionals \'96\'a0
\f2\b NSNotFound
\f1\b0  is effectively a magic number that means \'93not found\'94, assigned to a constant to make it easier to use.\
Here the 
\f2\b return
\f1\b0  statement is used in a new way: as part of an operation involving 
\f2\b ==
\f1\b0 . This is a very common way to code, and what happens is that 
\f2\b ==
\f1\b0  returns true or false depending on whether 
\f2\b misspelledRange.location
\f1\b0  is equal to 
\f2\b NSNotFound
\f1\b0 . That true or false is then given to 
\f2\b return
\f1\b0  as the return value for the method.\
We could have written that same line across multiple lines, but it's not common:\cf8 \
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  misspelledRange.location == \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 NSNotFound\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\} 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 false\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 That completes the third of our missing methods, so the project is almost complete. Run it now and give it a thorough test!\
Before we continue, there\'92s one small thing I want to touch on briefly. In the 
\f2\b isPossible()
\f1\b0  method we looped over each letter by treating the word as an array, but in this new code we use 
\f2\b word.utf16
\f1\b0  instead. Why?\
The answer is an annoying backwards compatibility quirk: Swift\'92s strings natively store international characters as individual characters, e.g. the letter \'93\'e9\'94 is stored as precisely that. However, UIKit was written in Objective-C before Swift\'92s strings came along, and it uses a different character system called UTF-16 \'96\'a0short for 16-bit Unicode Transformation Format \'96\'a0where the accent and the letter are stored separately.\
It\'92s a subtle difference, and often it isn\'92t a difference at all, but it\'92s becoming increasingly problematic because of the rise of emoji \'96\'a0those little images that are frequently used in messages. Emoji are actually just special character combinations behind the scenes, and they are measured differently with Swift strings and UTF-16 strings: Swift strings count them as 1-letter strings, but UTF-16 considers them to be 2-letter strings. This means if you use 
\f2\b count
\f1\b0  with UIKit methods, you run the risk of miscounting the string length.\
I realize this seems like pointless additional complexity, so let me try to give you a simple rule: when you\'92re working with UIKit, SpriteKit, or any other Apple framework, use 
\f2\b utf16.count
\f1\b0  for the character count. If it\'92s just your own code - i.e. looping over characters and processing each one individually \'96 then use 
\f2\b count
\f1\b0  instead.\cf2 \
\
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Or else what?
\f1\b0\fs35\fsmilli17600 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 There remains one problem to fix with our code, and it's quite a tedious problem. If the word is possible and original and real, we add it to the list of found words then insert it into the table view. But what if the word isn't possible? Or if it's possible but not original? In this case, we reject the word and don't say why, so the user gets no feedback.\
So, the final part of our project is to give users feedback when they make an invalid move. This is tedious because it's just adding 
\f2\b else
\f1\b0  statements to all the 
\f2\b if
\f1\b0  statements in 
\f2\b submit()
\f1\b0 , each time configuring a message to show to users.\
Here's the adjusted method:\
\pard\pardeftab720\partightenfactor0

\f2\b\fs36 \cf3 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 submit\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (answer: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ) \{\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  lowerAnswer = answer.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 lowercased\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  errorTitle: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  errorMessage: \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 String\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isPossible\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
        
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isOriginal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
            
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 isReal\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (word: lowerAnswer) \{\
                usedWords.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 insert\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (answer, at: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
\
                
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  indexPath = \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 IndexPath\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (row: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , section: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 0\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
                tableView.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 insertRows\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (at: [indexPath], with: .automatic)\
\
                
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
            \} 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
                errorTitle = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "Word not recognised"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
                errorMessage = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "You can't just make them up, you know!"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
            \}\
        \} 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
            errorTitle = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "Word used already"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
            errorMessage = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "Be more original!"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \}\
    \} 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{\
        
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 guard
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  title = title?.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 lowercased\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 () 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 else
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \{ 
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \}\
        errorTitle = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "Word not possible"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        errorMessage = \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "You can't spell that word from \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \\(\cf12 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 title\cf5 \cb4 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
    \}\
\
    
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  ac = \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 UIAlertController\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (title: errorTitle, message: errorMessage, preferredStyle: .alert)\
    ac.\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 addAction\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 UIAlertAction\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (title: \cf11 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "OK"\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , style: .
\f2\b \cf3 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 default
\f4\b0 \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ))\
    \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 present\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (ac, animated: \cf6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 As you can see, every 
\f2\b if
\f1\b0  statement now has a matching 
\f2\b else
\f1\b0  statement so that the user gets appropriate feedback. All the 
\f2\b else
\f1\b0 s are effectively the same (albeit with changing text): set the values for 
\f2\b errorTitle
\f1\b0  and 
\f2\b errorMessage
\f1\b0  to something useful for the user. The only interesting exception is the last one, where we use string interpolation to show the view controller's title as a lowercase string.\
If the user enters a valid answer, a call to 
\f2\b return
\f1\b0  forces Swift to exit the method immediately once the table has been updated. This is helpful, because at the end of the method there is code to create a new 
\f2\b UIAlertController
\f1\b0  with the error title and message that was set, add an OK button without a handler (i.e., just dismiss the alert), then show the alert. So, this error will only be shown if something went wrong.\
This demonstrates one important tip about Swift constants: both 
\f2\b errorTitle
\f1\b0  and 
\f2\b errorMessage
\f1\b0  were declared as constants, which means their value cannot be changed once set. I didn't give either of them an initial value, and that's OK \'96\'a0Swift lets you do this as long as you do provide a value before the constants are read, and also as long as you don't try to change the value again later on.\
Other than that, your project is done. Go and play!}