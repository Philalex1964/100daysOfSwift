{\rtf1\ansi\ansicpg1251\cocoartf2578
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 HelveticaNeue-Italic;
\f3\fnil\fcharset0 Menlo-Bold;\f4\fnil\fcharset0 Menlo-Italic;\f5\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red212\green212\blue212;\red222\green43\blue91;
\red215\green165\blue255;\red24\green24\blue28;\red246\green246\blue239;\red72\green212\blue251;\red235\green0\blue121;
\red248\green60\blue79;\red157\green101\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c86275\c86275\c86275;\cssrgb\c90588\c27059\c43137;
\cssrgb\c87843\c72157\c100000;\cssrgb\c12549\c12549\c14510;\cssrgb\c97255\c97255\c94902;\cssrgb\c32941\c86275\c98824;\cssrgb\c94902\c14118\c54902;
\cssrgb\c98824\c33725\c38039;\cssrgb\c68235\c50588\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid101\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid201\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\qc\partightenfactor0

\f0\b\fs98 \cf2 \expnd0\expndtw0\kerning0
DAY 39\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs28 \cf2 \
\pard\pardeftab720\partightenfactor0

\f0\b\fs70 \cf2 Project 9, part one\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs28 \cf2 \
\pard\pardeftab720\partightenfactor0

\fs35\fsmilli17600 \cf2 Joss Whedon, the creator of Firefly, once said that \'93the secret to multitasking is that it isn't actually multitasking \'96\'a0it\'92s just extreme focus and organization.\'94 (If you weren\'92t aware, Firefly played a big part in the development of Swift \'96\'a0the internal code name (\'93Shiny\'94) was from there, the original documentation mentioned the series a lot, and you\'92ll even find references to Firefly in my work!)\
Of course, computers operate very different from people: an iPhone XS has six CPU cores inside, and each of those six things can work independently of the others. If you use just one of them \'96 as we have been doing all this time \'96 then your app will never come close to using the full power of the device.\
So, to make the most of those cores we need to do 
\f2\i real
\f1\i0  multitasking: not just extreme focus and organization, but dividing up work that can happen simultaneously across as many cores as we need.\
This is traditionally A Very Hard Problem, but Apple has a framework called Grand Central Dispatch that makes it remarkably easy. It does, however, use 
\f2\i closures
\f1\i0 , so brace yourself!\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 Today you have five topics to work through, and you\'92ll learn about Grand Central Dispatch, quality of service queues, 
\f3 performSelector()
\f0 , and more.
\f1\b0 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/9/1/setting-up"}}{\fldrslt \expnd0\expndtw0\kerning0
Setting up}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/9/2/why-is-locking-the-ui-bad"}}{\fldrslt \expnd0\expndtw0\kerning0
Why is locking the UI bad?}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/9/3/gcd-101-async"}}{\fldrslt \expnd0\expndtw0\kerning0
GCD 101: async()}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/9/4/back-to-the-main-thread-dispatchqueuemain"}}{\fldrslt \expnd0\expndtw0\kerning0
Back to the main thread: DispatchQueue.main}}\expnd0\expndtw0\kerning0
\
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}{\field{\*\fldinst{HYPERLINK "https://www.hackingwithswift.com/read/9/5/easy-gcd-using-performselectorinbackground"}}{\fldrslt \expnd0\expndtw0\kerning0
Easy GCD using performSelector(inBackground:)}}\expnd0\expndtw0\kerning0
\
\pard\tx560\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Setting up\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs35\fsmilli17600 \cf2 In this technique project we're going to return to project 7 to solve a critical problem using one of the most important Apple frameworks available: Grand Central Dispatch, or GCD. I already mentioned the problem to you, but here's a recap from project 7:\

\f2\i By downloading data from the internet in 
\f4 viewDidLoad()
\f2  our app will lock up until all the data has been transferred. There are solutions to this, but to avoid complexity they won't be covered until project 9.
\f1\i0 \
We're going to solve this problem by using GCD, which will allow us to fetch the data without locking up the user interface. But be warned: even though GCD might seem easy at first, it opens up a new raft of problems, so be careful!\
If you want to keep your previous work for reference, take a copy of project 7 now and call it project 9. Otherwise, just modify it in place.
\f0\b\fs98 \

\f1\b0\fs35\fsmilli17600 \
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Why is locking the UI bad?
\f1\b0\fs35\fsmilli17600 \
The answer is two-fold. First, we used 
\f3\b Data
\f1\b0 's 
\f3\b contentsOf
\f1\b0  to download data from the internet, which is what's known as a 
\f2\i blocking
\f1\i0  call. That is, it blocks execution of any further code in the method until it has connected to the server and fully downloaded all the data.\
Second, behind the scenes your app actually executes multiple sets of instructions at the same time, which allows it to take advantage of having multiple CPU cores. Each CPU can be doing something independently of the others, which hugely boosts your performance. These code execution processes are called 
\f2\i threads
\f1\i0 , and come with a number of important provisos:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
Threads execute the code you give them, they don't just randomly execute a few lines from 
\f3\b viewDidLoad()
\f1\b0  each. This means by default your own code executes on only one CPU, because you haven't created threads for other CPUs to work on.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
All user interface work must occur on the main thread, which is the initial thread your program is created on. If you try to execute code on a different thread, it might work, it might fail to work, it might cause unexpected results, or it might just crash.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
You don't get to control when threads execute, or in what order. You create them and give them to the system to run, and the system handles executing them as best it can.\
\ls2\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
Because you don't control the execution order, you need to be extra vigilant in your code to ensure only one thread modifies your data at one time.\
\pard\pardeftab720\partightenfactor0
\cf2 Points 1 and 2 explain why our call is bad: if all user interface code must run on the main thread, and we just blocked the main thread by using 
\f3\b Data
\f1\b0 's 
\f3\b contentsOf
\f1\b0 , it causes the entire program to freeze \'96 the user can touch the screen all they want, but nothing will happen. When the data finally downloads (or just fails), the program will unfreeze. This is a terrible experience, particularly when you consider that iPhones are frequently on poor-quality data connections.\
Broadly speaking, if you\'92re accessing any remote resource, you should be doing it on a 
\f2\i background thread
\f1\i0  \'96 i.e., any thread that is not the main thread. If you're executing any slow code, you should be doing it on a background thread. If you're executing any code that can be run in parallel \'96 e.g. adding a filter to 100 photos \'96 you should be doing it on multiple background threads.\
The power of GCD is that it takes away a lot of the hassle of creating and working with multiple threads, known as 
\f2\i multithreading
\f1\i0 . You don't have to worry about creating and destroying threads, and you don't have to worry about ensuring you have created the optimal number of threads for the current device. GCD automatically creates threads for you, and executes your code on them in the most efficient way it can.\
To fix our project, you need to learn three new GCD functions, but the most important one is called 
\f3\b async()
\f1\b0  \'96 it means "run the following code asynchronously," i.e. don't block (stop what I'm doing right now) while it's executing. Yes, that seems simple, but there's a sting in the tail: you need to use closures. Remember those? They are your best friend. No, really.\
\
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 GCD 101: async()
\f1\b0\fs35\fsmilli17600 \
\pard\pardeftab720\partightenfactor0
\cf2 We're going to use 
\f3\b async()
\f1\b0  twice: once to push some code to a background thread, then once more to push code back to the main thread. This allows us to do any heavy lifting away from the user interface where we don't block things, but then update the user interface safely on the main thread \'96 which is the only place it can be safely updated.\
How you call 
\f3\b async()
\f1\b0  informs the system where you want the code to run. GCD works with a system of queues, which are much like a real-world queue: they are First In, First Out (FIFO) blocks of code. What this means is that your GCD calls don't create threads to run in, they just get assigned to one of the existing threads for GCD to manage.\
GCD creates for you a number of queues, and places tasks in those queues depending on how important you say they are. All are FIFO, meaning that each block of code will be taken off the queue in the order they were put in, but more than one code block can be executed at the same time so the finish order isn't guaranteed.\
\'93How important\'94 some code is depends on something called \'93quality of service\'94, or QoS, which decides what level of service this code should be given. Obviously at the top of this is the main queue, which runs on your main thread, and should be used to schedule any work that must update the user interface immediately even when that means blocking your program from doing anything else. But there are four background queues that you can use, each of which has their own QoS level set:\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls3\ilvl0\cf2 \kerning1\expnd0\expndtw0 {\listtext	1	}\expnd0\expndtw0\kerning0
User Interactive: this is the highest priority background thread, and should be used when you want a background thread to do work that is important to keep your user interface working. This priority will ask the system to dedicate nearly all available CPU time to you to get the job done as quickly as possible.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	2	}\expnd0\expndtw0\kerning0
User Initiated: this should be used to execute tasks requested by the user that they are now waiting for in order to continue using your app. It's not as important as user interactive work \'96 i.e., if the user taps on buttons to do other stuff, that should be executed first \'96 but it is important because you're keeping the user waiting.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	3	}\expnd0\expndtw0\kerning0
The Utility queue: this should be used for long-running tasks that the user is aware of, but not necessarily desperate for now. If the user has requested something and can happily leave it running while they do something else with your app, you should use Utility.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 {\listtext	4	}\expnd0\expndtw0\kerning0
The Background queue: this is for long-running tasks that the user isn't actively aware of, or at least doesn't care about its progress or when it completes.\
\pard\pardeftab720\partightenfactor0
\cf2 Those QoS queues affect the way the system prioritizes your work: User Interactive and User Initiated tasks will be executed as quickly as possible regardless of their effect on battery life, Utility tasks will be executed with a view to keeping power efficiency as high as possible without sacrificing too much performance, whereas Background tasks will be executed with power efficiency as its priority.\
GCD automatically balances work so that higher priority queues are given more time than lower priority ones, even if that means temporarily delaying a background task because a user interactive task just came in.\
There\'92s also one more option, which is the default queue. This is prioritized between user-initiated and utility, and is a good general-purpose choice while you\'92re learning.\cf3 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0
\cf2 Enough talking, time for some action: we're going to use 
\f3\b async()
\f1\b0  to make all our loading code run in the background queue with default quality of service. It's actually only two lines of code different:\cf3 \
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf5 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 global\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ().async \{\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 \'85before the code you want to run in the background, then a closing brace at the end. If you wanted to specify the user-initiated quality of service rather than use the default queue \'96 which is a good choice for this scenario \'96 you would write this instead:\cf3 \
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf5 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 global\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (qos: .userInitiated).async \{\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 The 
\f3\b async()
\f1\b0  method takes one parameter, which is a closure to execute asynchronously. We\'92re using trailing closure syntax, which removes an unneeded set of parentheses.\
Because 
\f3\b async()
\f1\b0  uses closures, you might think to start with 
\f3\b [weak self] in
\f1\b0  to make sure there aren\'92t any accident strong reference cycles, but it isn\'92t necessary here because GCD runs the code once then throws it away \'96 it won\'92t retain things used inside.\
To help you place it correctly, here's how the loading code should look:\cf3 \
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf5 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 global\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (qos: .userInitiated).async \{\
    
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  url = \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 URL\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (string: urlString) \{\
        
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  data = 
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 try
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ? \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Data\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (contentsOf: url) \{\
            
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 parse\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (json: data)\
            
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \}\
    \}\
\}\
\
\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 showError\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 Note that because our code is now inside a closure, we need to prefix our method calls with 
\f3\b self.
\f1\b0  otherwise Swift complains.\
If you want to try the other QoS queues, you could also use 
\f3\b .userInteractive
\f1\b0 , 
\f3\b .utility
\f1\b0  or 
\f3\b .background
\f1\b0 .\cf2 \
\
\pard\pardeftab720\partightenfactor0

\f0\b\fs98 \cf2 Back to the main thread: DispatchQueue.main\
\pard\pardeftab720\partightenfactor0

\f1\b0\fs35\fsmilli17600 \cf2 With this change, our code is both better and worse. It's better because it no longer blocks the main thread while the JSON downloads from Whitehouse.gov. It's worse because we're pushing work to the background thread, 
\f2\i and any further code called in that work will also be on the background thread
\f1\i0 .\
This change also introduced some confusion: the 
\f3\b showError()
\f1\b0  call will get called regardless of what the loading does. Yes, there\'92s still a call to 
\f3\b return
\f1\b0  in the code, but it now effectively does nothing \'96 it\'92s returning from the closure that was being executed asynchronously, not from the whole method.\
The combination of these problems means that regardless of whether the download succeeds or fails, 
\f3\b showError()
\f1\b0  will be called. And if the download succeeds, the JSON will be parsed on the background thread and the table view's 
\f3\b reloadData()
\f1\b0  will be called on the background thread \'96 and the error will be shown regardless.\
Let\'92s fix those problems, starting with the user interface background work. It's OK to parse the JSON on a background thread, but 
\f2\i it's never OK to do user interface work there
\f1\i0 .\
That's so important it bears repeating twice: 
\f0\b it's never OK to do user interface work on the background thread
\f1\b0 .\
If you're on a background thread and want to execute code on the main thread, you need to call 
\f3\b async()
\f1\b0  again. This time, however, you do it on 
\f3\b DispatchQueue.main
\f1\b0 , which is the main thread, rather than one of the global quality of service queues.\
We 
\f2\i could
\f1\i0  modify our code to have 
\f3\b async()
\f1\b0  before every call to 
\f3\b showError()
\f1\b0  and 
\f3\b parse()
\f1\b0 , but that's both ugly and inefficient. Instead, it's better to place the 
\f3\b async()
\f1\b0  call inside 
\f3\b showError()
\f1\b0 , wrapping up the whole 
\f3\b UIAlertController
\f1\b0  code, and also inside 
\f3\b parse()
\f1\b0 , but only where the table view is being reloaded. The actual JSON parsing can happily stay on the background thread.\
So, inside the 
\f3\b parse()
\f1\b0  method find this code:\cf3 \
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf7 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 tableView.\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 reloadData\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 \'85and replace it with this new code, bearing in mind again the need for 
\f3\b self.
\f1\b0  to make our capturing clear:\
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf5 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .main.async \{\
    
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .tableView.\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 reloadData\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 To stop 
\f3\b showError()
\f1\b0  being called regardless of the result of our fetch call, we need to move it inside the call to 
\f3\b DispatchQueue.global()
\f1\b0  in 
\f3\b viewDidLoad()
\f1\b0 , like this:\cf3 \
\pard\pardeftab720\partightenfactor0

\f5\fs36 \cf5 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 global\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (qos: .userInitiated).async \{\
    
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  url = \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 URL\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (string: urlString) \{\
        
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 if
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  data = 
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 try
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ? \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 Data\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (contentsOf: url) \{\
            
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 parse\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (json: data)\
            
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 return
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 \
        \}\
    \}\
\
    
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 showError\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ()\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 Remember, we need to add 
\f3\b self.
\f1\b0  to the 
\f3\b showError()
\f1\b0  call because it\'92s inside a closure now.\
But this has created a second problem: 
\f3\b showError()
\f1\b0  creates and shows a 
\f3\b UIAlertController
\f1\b0 \'a0\'96\'a0we now have user interface work happening on a background thread, which is always a bad idea.\
So, we need to modify 
\f3\b showError()
\f1\b0  to push that work back to the main thread, like this:\
\pard\pardeftab720\partightenfactor0

\f3\b\fs36 \cf9 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 func
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 showError\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 () \{\
    \cf5 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 DispatchQueue\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .main.async \{\
        
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 let
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0  ac = \cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 UIAlertController\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (title: \cf10 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "Loading error"\cf7 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , message: \cf10 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "There was a problem loading the feed; please check your connection and try again."\cf7 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , preferredStyle: .alert)\
        ac.\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 addAction\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 UIAlertAction\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (title: \cf10 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 "OK"\cf7 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 , style: .
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 default
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 ))\
        
\f3\b \cf9 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 self
\f5\b0 \cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 .\cf8 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 present\cf7 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 (ac, animated: \cf11 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 true\cf7 \cb6 \shad\shadx0\shady-20\shadr0\shado0 \shadc0 )\
    \}\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs35\fsmilli17600 \cf2 \cb1 \shad0 At this point, this code is in a better place: we do all the slow work off the main thread, then push work back to the main thread when we want to do user interface work. This background/foreground bounce is common, and you'll see it again in later projects.
\f0\b\fs98 \
\pard\pardeftab720\partightenfactor0

\f1\b0\fs35\fsmilli17600 \cf2 \
}